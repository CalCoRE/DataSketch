{"version":3,"sources":["modules/core/event/dispatcher.coffee"],"names":[],"mappings":"AAMA;AAAA,MAAA;;;;EAAA,MAAA,CAAO,SAAC,OAAD;AACL,QAAA;IAAA,KAAA,GAAQ,OAAA,CAAQ,SAAR;WAEF;;;;;;;;;;;gCAqBJ,gBAAA,GAAkB,SAAC,OAAD,EAAU,QAAV;AAEhB,YAAA;;UAAA,IAAC,CAAA,cAAe;;;cACH,CAAA,OAAA,IAAY;;QACzB,IAAA,CAAA,CAA2C,IAAC,CAAA,WAAY,CAAA,OAAA,CAAQ,CAAC,OAAtB,CAA8B,QAA9B,CAAA,IAA2C,CAAtF,CAAA;UAAA,IAAC,CAAA,WAAY,CAAA,OAAA,CAAQ,CAAC,IAAtB,CAA2B,QAA3B,EAAA;;eACA;MALgB;;gCAYlB,mBAAA,GAAqB,SAAC,OAAD,EAAU,QAAV;QACnB,IAAG,0BAAA,IAAkB,IAAC,CAAA,WAAY,CAAA,OAAA,CAA/B,IAA4C,aAAY,IAAC,CAAA,WAAY,CAAA,OAAA,CAAzB,EAAA,QAAA,MAA/C;UACE,IAAC,CAAA,WAAY,CAAA,OAAA,CAAQ,CAAC,MAAtB,CAA6B,IAAC,CAAA,WAAY,CAAA,OAAA,CAAQ,CAAC,OAAtB,CAA8B,QAA9B,CAA7B,EAAsE,CAAtE,EADF;;eAEA;MAHmB;;gCAerB,aAAA,GAAe,SAAC,GAAD,EAAM,IAAN,EAAiB,OAAjB;AACb,YAAA;;UADmB,OAAO;;;UAAI,UAAU;;QACxC,IAAG,wBAAH;UACE,IAAG,OAAO,GAAP,KAAc,QAAjB;YACE,GAAA,GAAU,IAAA,KAAA,CAAM,GAAN,EAAW,IAAX,EAAiB,OAAjB,EADZ;;;YAGA,GAAG,CAAC,SAAU;;UACd,GAAG,CAAC,aAAJ,GAAoB;AACpB;AAAA,eAAA,qCAAA;;YACE,IAAG,6BAAH;cACE,SAAA,GAAY,IAAC,CAAA,WAAY,CAAA,GAAA,CAAI,CAAC,KAAlB,CAAwB,CAAxB;AACZ,mBAAA,6CAAA;;gBAAA,EAAA,CAAG,GAAH;AAAA,eAFF;;AADF,WANF;;eAUA;MAXa;;gCAmBf,EAAA,GAAI,SAAA;AACF,YAAA;QADG;eACH,IAAC,CAAA,gBAAgB,CAAC,KAAlB,CAAwB,IAAxB,EAA2B,IAA3B;MADE;;gCAOJ,GAAA,GAAK,SAAA;AACH,YAAA;QADI;eACJ,IAAC,CAAA,gBAAgB,CAAC,KAAlB,CAAwB,IAAxB,EAA2B,IAA3B;MADG;;gCAOL,IAAA,GAAM,SAAA;AACJ,YAAA;QADK;eACL,IAAC,CAAA,aAAa,CAAC,KAAf,CAAqB,IAArB,EAAwB,IAAxB;MADI;;gCAiBN,WAAA,GAAa,SAAC,GAAD;QACX,IAAG,GAAG,CAAC,OAAP;iBACE,IAAC,CAAA,aAAD,CAAe,GAAf,EADF;;MADW;;;;;EArGV,CAAP;AAAA","file":"modules/core/event/dispatcher.js","sourceRoot":"/source/","sourcesContent":["# Event Dispatcher\n# ================\n\n# Base class for dispatching [Event](./event.html)s. Expect pretty much every\n# class to have this somewhere in its inheritence chain.\n\ndefine (require) ->\n  Event = require './event'\n\n  class EventDispatcher\n    \n# Public API\n# ==========\n\n# `addEventListener(eventName, callback)`\n\n# Registers a callback function to be called when an event with the specified\n# name is fired by this object. This callback is considered to be \"listening\" for\n# that event.\n\n# The callback should expect a single argument, which will be an\n# [Event](./event.html) object.\n\n# There are two points to note:\n\n# 1. The same callback set to listen for the same event will only be called\n#   once.\n# 2. Since lambda functions are always considered to be different with each\n#   declaration, they should not be used as callbacks for events.\n    \n    addEventListener: (evtName, callback) =>\n      #lazily create the listener collections\n      @__listeners ?= {}\n      @__listeners[evtName] ?= []\n      @__listeners[evtName].push callback unless @__listeners[evtName].indexOf(callback) >= 0\n      @\n\n    \n# `removeEventListener(eventName, callback)`\n\n# Stops a listener from listening to the specified event.\n    \n    removeEventListener: (evtName, callback) =>\n      if @__listeners? and @__listeners[evtName] and callback in @__listeners[evtName]\n        @__listeners[evtName].splice @__listeners[evtName].indexOf(callback), 1\n      @\n\n    \n# `dispatchEvent(event)`, `dispatchEvent(eventName, data = {}, bubbles = false)`\n\n# Fires an event, calling all of the callbacks in the order they were added.\n# If the first argument is a string, then it is assumed to be the event's name,\n# and a proper Event object is created on the fly.\n\n# Once all callbacks bound to the specific event name are fired, callbacks bound\n# to all event using the wildcard (\"*\") name are fired.\n    \n    dispatchEvent: (evt, data = {}, bubbles = false) =>\n      if @__listeners?\n        if typeof evt == \"string\"\n          evt = new Event evt, data, bubbles\n\n        evt.target ?= @\n        evt.currentTarget = @\n        for key in [evt.name, \"*\"]\n          if @__listeners[key]?\n            listeners = @__listeners[key].slice 0\n            cb(evt) for cb in listeners\n      @\n    \n# API Aliases\n# ===========\n# `on(eventName, callback)`\n\n# Shorthand for `addEventListener`.\n    \n    on: (args...) =>\n      @addEventListener.apply(@, args)\n    \n# `off(eventName, callback)`\n\n# Shorthand for `removeEventListener`.\n    \n    off: (args...) =>\n      @addEventListener.apply(@, args)\n    \n# `fire(event)`, `fire(eventName, data = {}, bubbles = false)`\n\n# Shorthand for `dispatchEvent`.\n    \n    fire: (args...) =>\n      @dispatchEvent.apply(@, args)\n\n    \n# Utilities\n# =========\n\n# `bubbleEvent(event)`\n\n# Event listener to fire any bubbling events. Normal usage of this looks\n# something like the following:\n\n#     child.addEventListener \"*\", parent.bubbleEvent\n\n# This allows the parent to fire any events that the child fires up the chain,\n# restricted only to the events that are specified to bubble.\n    \n    bubbleEvent: (evt) =>\n      if evt.bubbles\n        @dispatchEvent(evt)\n"]}